# Конвенции по коду в специфике C#
## SOLID, архитектура
Слушаемся принципов SOLID, планируем код наперед

## Нейминг
Слушаемся конвенций языка:
1. Классы в `PascalCase`
2. Методы в `PascalCase`
3. Свойства в `PascalCase`
4. Поля в `_lowerPascalCase` (поля не делаем публичными, только свойства)
5. Переменные в `lowerPascalCase`
6. Интерфейсы префиксим с I
7. Классы называем существительными
8. Методы называем глаголами
9. Названия классов, методов и переменных должны быть минимальной длины, при которой можно полноценно описать их функционал. Лишнего не сокращаем
10. Аббревиатуры длиннее **2** символов пишем в PascalCase (`AIService` и `RuClipService`)

## Пространства имен, структура
1. Пространства имен должны соответствовать структуре проекта
2. Пространства имен и папки должны называться в `PascalCase`
3. Распределяем классы по логичной, адекватной структуре

## Комментарии
1. Для классов и методов пишем документацию в формате XML (`///`)
2. Для кода пишем комментарии в отдельную строку через `//`
3. В коротких строках комментарии можно писать на одной строке с кодом, обязательно после. Между кодом и комментарием должно быть два пробела
4. Между `//` и комментарем должен быть один пробел
5. Если нужно использовать многострочные комментарии, используем `/**/`, а не несколько строк `//`

## Модификаторы
1. Грамотно используем модификаторы доступа
2. Грамотно используем `static`, `abstract` и т.п.

## async/await
1. Используем `async/await` и `Task` для IO-операций (сетевые запросы, работа с файлами, БД)
2. Постфиксим названия методов с `Async` (`public async Task<User> GetUserAsync (int id)`)
3. Когда работаем с асинхронностью, используем CancellationToken

## Nullability
1. Не забываем проверки на `null`
2. Не забываем возвращать `null` или `Exception`

## Исключения
1. Не забываем ловить исключения
2. Выбрасываем исключения подходящего типа, описывающего суть ошибки
3. Не забываем писать текст, описывающий ошибку. Где надо, передаем `nameof()` для соответствующего аргумента

## Логгирование
1. Пишем логи достаточно часто (по ним должно быть просто отследить, что, где и когда пошло не так)
2. Логи пишем с соответствующим уровнем серьезности

## Dependency Injection
1. Не забываем инжектить сервисы, если есть общий интерфейс (а он почти всегда должен быть) - инжектим по нему
2. `ILogger` принимаем как generic, передавая тип текущего сервиса (*например, в классе PlacesService: `public PlacesService (ILogger<PlacesService> logger) { ... }`*)
3. Принимаем грамотные решения по жизненному циклу сервисов

## Юнит-тесты
1. Используем моки. В тестах не должно быть запросов к реальным API, БД и т.п.. Это юнит-тесты, а не интеграционные, мы тестируем только наше приложение, а не всю систему
2. Не забываем про правильный нейминг и комментарии в тестах